<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace 命名空间，作用就是对sql进行分类化管理，理解sql隔离
	注意：使用namespace 代理方法开发，namespace 有特殊重要的作用,namesapce等于mapper接口地址
 -->

<mapper namespace="cn.itcast.mybatis.mapper.UserMapper">
		<!-- 定义sql 片段
			id:sql片段的唯一标识
			经验：是基于单标来定义sql片段，这样的话这个sql 片段可重用性才高、
			sql片段一般不包含where，为了提高可重用性
		  -->
		  <sql id="query_user_where">
		   
		   	 	<if test="userCustom!=null">
		   	 		<if test="userCustom.sex!=null and userCustom.sex!=''">
		   	 			and user.sex=#{userCustom.sex}
		   	 		</if>
		   	 		<if test="userCustom.username!=null and userCustom.username!=''">
		   	 			and user.username=#{userCustom.username}
		   	 		</if>
		   	 	
		   	 	</if>
		   	
		  </sql>
	

		<!-- 定义resultMap
			将select id id_,username username_ from user 和User 类中的属性做一个映射关系
			type:resultMap 最终所映射的java 对象类型，可以使用别名
			id:对resultMap 的唯一标识
		 -->
		 <resultMap type="user" id="userResultMap">
		 	<!-- id表示查询结果集中唯一标识
		 		column:查询出来的列名
		 		property:type 指定的pojo类型中的属性名
		 		 最终resultMap对column 和property做一个映射关系（对应关系）
		 	 -->
		 	 <id column="id" property="id_"/>
		 	 <!-- result:对普通名映射定义
		 	 	column:查询出来的列名
		 	 	property:type指定的pojo类型中的属性名
		 	 	 最终resultMap对column 和property做一个映射关系（对应关系）
		 	  -->
		 	 <result column="username" property="username_"/>
		 </resultMap>
		
		<!--  在映射文件中配置很多sql 语句 
			需求：通过id查询用户表的记录
		-->
		<!-- 通过select 执行数据库查询
			id：标识映射文件中的sql ,将sql语句封装到mapped Statement对象中，所有将id 称为statement 的id
			#{}表示一个占位符号
			#{id}:其中的id表示接收输入的参数，参数名为id,如果输入的参数名为简单类型，#{}中的参数名可以任意，可以value 也可以其他
			resultType:指定SQL输出结果的所映射的java 对象类型，select指定resultType 表示将单条记录映射成的java 对象
		 -->
		 
		 <select id="findUserById" parameterType="int" resultType="cn.itcast.mybatis.po.User">
		 	SELECT * FROM USER WHERE id=#{id}
		 </select>
		 <!-- 使用resultMap 进行输出的映射
		 	resultMap ：指定定义的resultMap的id,如果这个resultMap在其他的mapper文件，前边需要加namespace
		 	总结:
		  -->
		 <select id="findUserByIdResultMap" parameterType="int" resultMap="userResultMap">
		 	select id,username from user where id=#{value}
		 </select>
		 <!-- 根据用户名称模糊查询用户信息，可能返回多条
		 	resultType:指定就是单条记录所映射的java对象类型
		 	${}:表示拼接sql 语句，将接收到的参数内容不加任何修饰拼接在sql 中
		  -->
		 <select id="findUserByName" parameterType="java.lang.String" resultType="cn.itcast.mybatis.po.User">
		 	   select * from user where username LIKE '%${value}%' 
		 	<!-- select * from user where username LIKE #{value} -->
		 </select>	
		 <!-- 添加用户
		 	parameterType:指定输入参数类型是pojo(包括用户信息)
		 	#{}中指定pojo的属性名，接收到pojo 对象的属性值  ，mybatis 通过OGNL获取对象的属性值
		  -->
		  <insert id="insertUser" parameterType="user">
		  <!-- 将插入数据的主键返回，返回到user对象中
		  	SELECT LAST_INSERT_ID()：得到刚insert 进去记录的主键值，只适用于自增主键
		  	keyProperty：将查询到主键值设置到parameterType 指定的对象的那个属性
		  	order:SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序
		  	resultType:指定SELECT LAST_INSERT_ID()的结果类型
		   -->
		   <!--  1,自增主键的返回 -->
		 	<!-- <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
		 	SELECT LAST_INSERT_ID()
		 	</selectKey> -->
		 	<!-- 2,非自增主键的返回
		 		使用mysql的uuid()生成主键
		 		前提条件：需要将id的类型设置为String ，并且字段长度设为35；
		 		执行过程：
		 			首先通过uuid()得到主键，将主键设置到user对象的id属性中，
		 			其次在insert执行时，从user对象中取出id属性值
		 	 -->
		 	<!--  <selectKey keyProperty="id" order="BEFORE" resultType="java.lang.String">
		 	SELECT uuid()
		 	</selectKey> -->
		  	insert into user(id,username,birthday,sex,address) value(#{id},#{username},#{birthday},#{sex},#{address})
		  </insert>
		  
		  <!-- 删除用户 -->
		  <delete id="deleteUser" parameterType="java.lang.Integer">
		  		delete from user where id=#{id}
		  </delete>
		  <!-- 更新用户
		  	分析：
		  		需要传入用户的id
		  		需要传入用户的更新信息
		  		parameterType指定user对象，包括id和更新信息，注意：id必须存在，不然就更新了所有的
		  		#{id} :从输入user对象中获取id属性值
		  		
		   -->
		  <update id="updateUser" parameterType="user">
		  	update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=
		  	#{id}
		  </update>
		  
		  <!-- 用户信息综合查询 -->
		  <!-- 
		  	#{userCustom.sex}:取出pojo包装对象中性别值
		  	${userCustom.username} :取出pojo包装对象中用户名称
		  	 -->
		  <select id="findUserList" parameterType="UserQueryVo" resultType="UserCustom">
		  	select * from user 
		  	<!-- where user.sex=#{userCustom.sex} and user.username like '%${userCustom.username}%' -->
		  	<where>
		  	<!-- 引用sql片段的id,如果refid指定的id不在本mapper文件中，需要前边加namespace -->
		  		<include refid="query_user_where"></include>
		  		<!-- 在这里还要引用其他的SQL片段 -->
		  	</where>
		  </select>
		  
		  <!-- 注意：
		  	resultType：
		  	使用resultType进行输出映射，只有查询出来的列名和pojo 中的属性名一致，该列才可以映射成功
		  	如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象
		  	如果查询出来的列名和pojo中的属性有一个不一致，就会创建pojo对象
		  	resultMap:
		  		如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap 对列名和属性名之间做一个映射关系
		  		1，定义resultMap
		  		2，使用resultMap 作为statement 的输出映射类型
		  	
		   -->
		   <!-- 输出简单类型 -->
		   <select id="findUserCount" parameterType="UserQueryVo" resultType="int">
		   	select count(*) from user
		   	 <!-- where sex=#{UserQueryVo.sex} and username like '%${UserQueryVo.username}%' -->
		   	
		   	<!-- 动态sql
		   		where 可以自动去掉条件中的第一个and 
		   	 -->
		   	 <where>
		   	 	<if test="userCustom!=null">
		   	 		<if test="userCustom.sex!=null and userCustom.sex!=''">
		   	 			and user.sex=#{userCustom.sex}
		   	 		</if>
		   	 		<if test="userCustom.username!=null and userCustom.username!=''">
		   	 			and user.username=#{userCustom.username}
		   	 		</if>
		   	 	
		   	 	</if>
		   	 </where>
		   </select>
		   
		   <!-- 输出pojo对象和pojo对象 ：
		   		小结：
		   			不管是输出的pojo单个对象还是一个列表（list中包括pojo，）在mapper.xml中resultType 指定的类型都是一样 的，
		   			在mapper.java指定的方法返回值类型不一样
		   				1，输出单个pojo对象，方法返回值是单个对象类型
		   				
		   				2， 输出pojo对象list，方法返回值是list<pojo>
		   			注意；生成的动态代理对象中是根据mapper方法的返回值类型确定是调用的selectOne 还是调用的是selectList 方法
		   		
		   	-->
		   	<!-- 
		   		sql 片段：
		   			将上边实现的动态slq 判断代码块抽取出来，组成一个sql 片段，其他的statement 中就可以引用sql片段
		   	 -->
		  
		
</mapper>